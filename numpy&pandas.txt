
---------------Vectorised operations--------------- 
A vector is a list of numbers .
vector1=1,2,3 	vector2=4,5,6
Adding 2 vectors is called vector addition .
vector1+vector2=5,7,9

vector1 * scalar (i.e 3)=3,6,9
More Vectorised operations:
Math operations			Logical operations			Comparison operations		
Add:+					And &						Greater:>
subtract:-				or : |						Greater or equal:>=
Multiply:*				Not: ~						Less:< ,Less or equal <=
Divide :/				Make sure your array has 	equal:==,not equal:!=
Exponentiate: **		boolean values 

------------------Difference between + and += in numpy----------------
code snippet 1 
import numpy as np 
a=np.array([1,2,3,4])
b=a 
a+=np.array([1,1,1,1])
print b 
o/p array([2,3,4,5])
explanation:
when we do b=a both a and b points to array[1,2,3,4]
now we add a with 1,1,1,1 .so the resultant gets updated & becomes [2,3,4,5]
note here still a & b both points to same array and it has got incremented by the operation 
so, print b or print a will yield same result i.e [2,3,4,5]

code snippet 2
import numpy as np 
a=np.array([1,2,3,4])
b=a 
a=a+np.array([1,1,1,1])
print b 
o/p array([1,2,3,4])
explanation 
b=a ,both points to same array i.e [1,2,3,4]
however + operator without equal sign creates a new array first 
i.e now a no longer points to [1,2,3,4] rather it points to old value + [1,1,1,1]
i.e a now equals [2,3,4,5]
so , print b will give [1,2,3,4] as b still points to it.

-------------------In-Place vs Not In-Place------------------
+= operates in place whereas + doesn't 
i.e += stores the new value in the same place rather than creating a new array and store 
code snippet:
a=np.array([1,2,3,4,5])
slice=a[:3]
slice[0]=100
print a 
o/p- array([100,2,3,4,5])
explanation:
slice in numpy is different from list slicing in python where it actually slices the elements and 
creates a new list. however in numpy slice will still refer to the same index numbers mentined
i.e slice=a[:3] refers to the same array but to only 1st 3 elements 
so slice[0]=100 updates the value from 1 to 100 
both a and slice(for 1st 3 elements) refers to same array .
Now 0th element has got updated to 100. 
so final o/p is array([100,2,3,4,5])

--------------------Pandas Series---------------------
A series is similar to numpy array but with extra functionality.
for e.g if we have a series named s and s.describe() -will print out mean, std deviation and 
some other statistics about the series ,which is not in numpy array 

similarity b/w numpy and pandas 
.Accessing elements -s[0] ,s[3:7]
.looping for x in s 
.convenient function -s.mean() ,s.max()
.Vectorised operation-s1+s2
.Implemented in C(fast)

note: panda series does an enumeration 
e.g life_expectancy = pd.Series(life_expectancy_values)
where life_expectancy_values are a collection of array like [1,2,3...]
print life_expectancy will give o/p as :
0     74.7
1     75.0
2     83.4
.....

note:difference between numpy and pandas 
numpy arrays are souped up versions of python list 
panda series is a cross between a list and dictionary 
in numpy we create an index and data point with 2 different arrays 
for e.g 
life_expectancy=np.array([71,76,72,74])
countries=np.array(["Afganistan","Bhutan","Bulgaria","Canada"])
here we have 1-1 relation between countries and life_expectancy but with 2 different arrays

but in pandas we can create a single series to hold the index's too 
life_expectancy=pd.Series([71,76,72,74],
						index=["Afganistan","Bhutan","Bulgaria","Canada"])
>>> life_expectancy
Afganistan    71
Bhutan        76
Bulgaria      72
Canada        74
dtype: int64

>>> life_expectancy[0]
71
>>> life_expectancy.loc['Bhutan'] - loc access element by index names 
76

iloc - to access element by position
>>> life_expectancy.iloc[0]
71

if you create a series without any index then by default numbers 0,1,2.. will act as index 
for e.g 
x=pd.Series([71,76,72,74])
print x
0    71
1    76
2    72
3    74
dtype: int64

-------------------------Vectorised operation and Series Indexes-------------------------------
When you add 2 numpy array then you add by its position since no index is there .
what if you add 2 series with different index?
Ans-look out for the example in pandaVectorIndex.py 

--------------NonBuilt in Calculations-----------------------
To achieve this :
1.Treat the series as list (for loops etc)
2.use the function apply()
	-apply takes a series and a function and returns a new series by applying function to 
	every element of the original series 
e.g def add3(x): return x+3 
let series s = [1,2,3] calling the add3 will add 3 to all element 4,5,6
s+3=s.apply(add3)

-----------------------Plotting in Pandas--------------------------
If the variable data is a NumPy array or a Pandas Series, just like if it is a list, the code

import matplotlib.pyplot as plt
plt.hist(data)
will create a histogram of the data.

Pandas also has built-in plotting that uses matplotlib behind the scenes, 
so if data is a Series, you can create a histogram using data.hist().

There's no difference between these two in this case, but sometimes the Pandas wrapper 
can be more convenient. For example, you can make a line plot of a series using data.plot(). 
The index of the Series will be used for the x-axis and the values for the y-axis.

-----------------------------2D Data------------------------------
In Python : List of List
In NumPy : 2D array
In Pandas : DataFrame

2D array as opposed to array of arrays 
-more efficient 
-Accessing elements is a bit different
 a[1,3] as rather than a[1][3]
-mean(),std() etc operates on entire array

note: 
-A DataFrame is also a 2D data str but each col is assumed to be different type 
wheareas for numpy 2D array entire array is of one type 
-DataFrame have indexes similar to pandas theories 

loc - to access row by indexes
iloc - to access by position its like array position 
for more 
-----------Operation along axis--------------
ridership.mean(axis=0) 
if axis=0 then mean calculated for each column if its 1 then calculated for each row 

 --------------Calculating Correlation(Pearson's r)--------------------------
 x1 ,y1 <--- both above the mean ? both below ? one above and one below?
 x2 ,y2 
 ....
 Pearson's r - ranges from -1 to +1 
 .1st standardize each var (i.e above or below mean)
 .Multiply each pair of values and take the average 
	r=average of (x in std units)*(y in std units)

-----------Pandas Axis Name---------------------------
Instead of axis =0 or axis =1,you can use axis='index' or axis='columns'
DataFrame vectorised operations -see the pandaDataframeVector.py	

applymap - on dataframe tranfroms each element in the dataframe to another element
for e.g converting marks to grades - see pandaDataframeApplyMap.py

DataFrame apply :apply on dataframe is direct analog of apply on series .it depends on what you 
consider a single piece of dataframe.you could say a single piece is a column rather than a single 
element .
function takes a series of a dataframe(which is a col) and retuns a new series of dataframe(new col)
e.g df.apply(f) - will perform operation on entire col . 
Q. why do we need apply rather than applymap 
A- this may be because of your requirement which works on full col rather than working on a element
e.g grading on a curve 
suppose i want to give an A to 20% of students with highest grades ,B to 30% ,D to 10% ,F to 10%
see pandaDataframeMap.py where we standardize each col of a dataframeS

use case 2 of apply : 
here instead of tranfroming a col to new col using apply , the function can convert 
the col to a single value e.g if you want to find the maximum value in each col 
df.apply(np.max) is equal to df.max or to find the second largest item in each col 
e.g see pandaDataframeMap2.py

---------------------Three-Dimensional Data----------------
Now that you've worked with one-dimensional and two-dimensional data, you might be wondering how to work with three or more dimensions.

3D data in NumPy
NumPy arrays can have arbitrarily many dimensions. Just like you can create a 1D array from a list, and a 2D array from a list of lists, you can create a 3D array from a list of lists of lists, and so on. For example, the following code would create a 3D array:

a = np.array([
    [['A1a', 'A1b', 'A1c'], ['A2a', 'A2b', 'A2c']],
    [['B1a', 'B1b', 'B1c'], ['B2a', 'B2b', 'B2c']]
])
3D data in Pandas
Pandas has a data structure called a Panel, 
which is similar to a DataFrame or a Series, but for 3D data.
 	