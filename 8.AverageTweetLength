

package com.SimpleSparkDemo
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
import org.apache.spark.streaming._
import org.apache.spark.streaming.twitter._
import org.apache.spark.SparkConf
import org.apache.spark.streaming.{StreamingContext,Seconds}
import org.apache.log4j.Level
import org.apache.spark.streaming.twitter.TwitterUtils
import twitter4j._
import java.util.concurrent.atomic.AtomicLong

object AverageTweetLength extends App {
   // configure twitter credentials 
  System.setProperty("twitter4j.oauth.consumerKey", "9o6bMytdK03TezQ3H8x83UklJ")
  System.setProperty("twitter4j.oauth.consumerSecret", "1dFuzX9lF9mbUoJYc6gwC9pjTDY0s3dG2tq9veLaSHkzIWClX3")
  System.setProperty("twitter4j.oauth.accessToken", "913410683135434753-yp8Bzpil1P7vWcf1MrdllgkF1fFiwWm")
  System.setProperty("twitter4j.oauth.accessTokenSecret", "EBfYdCzBjnMXsVLFCIGAd4djoYNMWTFovUUnAS6ZdWxOy")

  val conf = new SparkConf().setAppName("Save Tweets").setMaster("local[2]")
  val ssc = new StreamingContext(conf,Seconds(1))  // Seconds(1) - batch size of 1 
  
  //Create DStream from twitter using streaming Context 
  val tweets = TwitterUtils.createStream(ssc,None)
   
  
   
  // Now extract the text of each status update into RDD's using map()
  val statuses = tweets.map(status => status.getText())
  //statuses.print() - this dStream contains only text 
  
  //Map this to tweet character lengths .
  val lengths = statuses.map(status => status.length())
  
  // As we could have multiple processes adding into these running totals 
  //at the same time ,we'll just Java's AtomiLong classes to make sure 
  // these 2 are used to calculate the average lenth 
  
  var totalTweets = new AtomicLong(0) 
  var totalChars =  new AtomicLong(0)
  var maxLength = new AtomicLong(0) 
  
  // In Spark 1.6+ ,you might also look into the mapWithstate Function ,which allows 
  // you to safely and effectively keep track of global state with key/value pairs 
  // these counters are thread safe 
  
  lengths.foreachRDD((rdd,time) => {
    var count = rdd.count()
    if (count > 0) {
      totalTweets.getAndAdd(count)
      totalChars.getAndAdd(rdd.reduce((x,y) => x+y )) // combine all things in rdd with 1 final value 
      
       
      println("Total Tweets: " + totalTweets.get() + 
             " Total Characters:"  + totalChars.get() +
             " Average :" + totalChars.get() / totalTweets.get() ) 
             
      
    }
  })
  
  ssc.start() // Start the computation
  ssc.awaitTermination() // Wait for the computation to terminate

 
}
